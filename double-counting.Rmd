---
title: "Double counting"
author: "Kelly Hondula"
date: "6/10/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(vroom)
library(fs)
library(dplyr)
library(raster)
library(sf)
library(purrr)
```

Water cells in multiple polygons in each image. Filter cell IDs to mvdeps and water, then group by cell ID

```{r}
rf_predicts_files <- fs::dir_ls("/nfs/khondula-data/planetmethane/results/rf_predicts_noEHW_pixels")
rf_predicts_file <- rf_predicts_files[1]
```

On one image

```{r}
# read in
rf_predicts <- rf_predicts_file %>% 
  vroom::vroom(col_types = c("iddddddddddddlllcddcc")) %>%
  dplyr::select(cellindex, water_training, mvdeps, imgID, x, y, ID_sp, ranger_predict)
# filter to water and find double counts
rf_predicts_dc <- rf_predicts %>% 
  filter(mvdeps, ranger_predict == 'water') %>% 
  group_by(cellindex, x, y) %>%
  summarise(n_polygons = n()) %>% 
  arrange(desc(n_polygons)) %>% 
  filter(n_polygons > 1)
```

Now for each cell index, need to assign it to a polygon ID_sp based on polygon that is closest to cell index xy
```{r}
my_cellindices <- rf_predicts_dc[['cellindex']]
my_cellindx <- my_cellindices[1]
mvdeps_overlaps <- rf_predicts %>% 
  dplyr::filter(cellindex == my_cellindx) %>%
  pull(ID_sp)
```

```{r}
masked_layer_files <- fs::dir_ls("data/imgs_for_analysis")
masked_layer_files_nfs <- gsub("data", "/nfs/khondula-data/planetmethane", masked_layer_files)

img_file <- rf_predicts_file %>%
  basename() %>% 
  substr(11, 30) %>%
  grep(masked_layer_files_nfs, value = TRUE)

# load in image and the overlapping polygons
imgstack <- raster::stack(img_file)[[1]]
mvdeps_sf <- st_read("/nfs/khondula-data/planetmethane/polygons/mvdeps_buff20_inNLCD.shp")
mvdeps_sub <- mvdeps_sf %>%
  dplyr::filter(dep_id %in% mvdeps_overlaps)
mvdeps_centroids <- mvdeps_sub %>% sf::st_centroid()

centroid_xys <- raster::extract(imgstack, mvdeps_centroids, cellnumbers = TRUE, df = TRUE) %>%
  dplyr::pull(cells) %>%
  purrr::map(~as.data.frame(raster::xyFromCell(imgstack, cell = .x))) %>% 
  bind_rows() %>% 
  mutate(dep_id = mvdeps_overlaps) 

centroids_sf <- st_as_sf(centroid_xys, coords = c("x", "y"))
mycell_sf <- raster::xyFromCell(imgstack, cell = my_cellindx) %>% st_point()

mvdep_closest <- mvdeps_overlaps[which.min(st_distance(mycell_sf, centroids_sf))]
```

Function to return id of closest mvdep given an image and cellindex

```{r}
find_closest_mvdep <- function(rf_predicts_file, my_cellindx){
  masked_layer_files <- fs::dir_ls("/nfs/khondula-data/planetmethane/imgs_for_analysis")
  img_file <- rf_predicts_file %>%
    basename() %>% 
    substr(11, 30) %>%
    grep(masked_layer_files, value = TRUE)
  
  mvdeps_overlaps <- rf_predicts_file %>% 
    vroom::vroom(col_types = c("iddddddddddddlllcddcc")) %>%
    dplyr::filter(cellindex == my_cellindx) %>%
    dplyr::pull(ID_sp)
  
  # load in image and the overlapping polygons
  imgstack <- raster::stack(img_file)[[1]]
  mvdeps_sf <- st_read("/nfs/khondula-data/planetmethane/polygons/mvdeps_buff20_inNLCD.shp")
  mvdeps_centroids <- mvdeps_sf %>%
    dplyr::filter(dep_id %in% mvdeps_overlaps) %>% 
    sf::st_centroid()

  centroid_xys <- raster::extract(imgstack, mvdeps_centroids, cellnumbers = TRUE, df = TRUE) %>%
    dplyr::pull(cells) %>%
    purrr::map(~as.data.frame(raster::xyFromCell(imgstack, cell = .x))) %>% 
    dplyr::bind_rows() %>% 
    dplyr::mutate(dep_id = mvdeps_overlaps) 

  centroids_sf <- sf::st_as_sf(centroid_xys, coords = c("x", "y"))
  mycell_sf <- raster::xyFromCell(imgstack, cell = my_cellindx) %>% st_point()

  mvdep_closest <- mvdeps_overlaps[which.min(st_distance(mycell_sf, centroids_sf))]
  mvdep_dc <- mvdeps_overlaps[-which.min(st_distance(mycell_sf, centroids_sf))]
  return(list(mvdep_dc))
}
```

```{r}
closest_mvdeps_rf1 <- purrr::map(my_cellindices[1:10],
                                     ~find_closest_mvdep(rf_predicts_files[1], 
                                                         my_cellindx = .x))
```

Then use the closest mvdeps vector to update rf_predicts file, new row to filter out the polygons that are double counts

```{r}
rf_predicts_files <- fs::dir_ls("/nfs/khondula-data/planetmethane/results/rf_predicts_noEHW_pixels")

calc_double_count_percentage <- function(rf_predicts_file){
  
rf_predicts <- rf_predicts_file %>% 
  vroom::vroom(col_types = c("iddddddddddddlllcddcc")) %>%
  dplyr::select(cellindex, water_training, mvdeps, imgID, x, y, ID_sp, ranger_predict)

rf_predicts_dc <- rf_predicts %>% 
  filter(mvdeps, ranger_predict == 'water') %>% 
  group_by(cellindex) %>%
  summarise(n_polygons = n()) %>% 
  arrange(desc(n_polygons)) %>% filter(n_polygons > 1)

water_pix <- rf_predicts %>% filter(mvdeps, ranger_predict == 'water') %>% nrow()
water_pix_dc <- rf_predicts_dc %>% nrow()

percentage_dc <- water_pix_dc/water_pix

# actually should calculate both the absoluate number (area) and percentage
return(list("water_pix" = water_pix,
            "water_pix_dc" = water_pix_dc, 
            "dc_percentage" = percentage_dc))
}

calc_double_count_percentage('/nfs/khondula-data/planetmethane/results/rf_predicts_noEHW_pixels/rfpredict_20180708_151405_104e.csv')

dc_percentages <- purrr::map(rf_predicts_files, ~calc_double_count_percentage(.x))

dc_percentages_df <- data.table::rbindlist(dc_percentages, fill = TRUE, idcol = TRUE) %>%
  as.data.frame()

dc_percentages_df %>% 
  mutate(imgID = substr(basename(.id), 11, 30)) %>%
  mutate(imgDate = as.Date(substr(imgID, 1, 8), "%Y%m%d")) %>%
  dplyr::select(-.id) %>%
  ggplot(aes(x = imgDate, y = dc_percentage)) +
  geom_point() + theme_bw()

dc_percentages_df %>% 
  mutate(imgID = substr(basename(.id), 11, 30)) %>%
  mutate(imgDate = as.Date(substr(imgID, 1, 8), "%Y%m%d")) %>%
  dplyr::select(-.id) %>%
  ggplot(aes(x = imgDate, y = water_pix_dc)) +
  geom_point() + theme_bw()

dc_percentages %>% as.data.frame() %>% tibble::rownames_to_column() %>%
  # pull(.) %>% summary()
  ggplot(aes(x = .)) + geom_histogram(binwidth = .01)
  View()
# rf_predicts_dc %>% left_join(rf_predicts) %>% pull(ID_sp) %>% unique() %>% length()
# rf_predicts_dc
dc_percentages_df$dc_percentage %>% summary()
dc_percentages_df$water_pix_dc %>% summary()*9/1e6
```

```{r}
rf_predicts_dc$n_polygons %>% table()
```

Area associated with the polygons that are removed from analysis (approx 300 polygons)

```{r}
mydep_ids <- substr(list.files(file.path(data_dir, "results", "ch4_flux_predicts")), 8, 12)
mvdeps_buffered_areas %>%
  filter(!dep_id %in% mydep_ids) %>% summarise(sum_area_excluded = sum(area_m2)/1e6)
```

